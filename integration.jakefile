// Copyright (c) 2012 Titanium I.T. LLC. All rights reserved. See LICENSE.txt for details.

var BUILD_COMMAND = "./jake.sh";

/*global desc, task, jake, fail, complete */
(function() {
	"use strict";

	task("default", function() {
		console.log(
			"Usage:\n" +
			"1. When starting fresh, run 'reset' to get back to known-good state.\n" +
			"2. When you're ready to integrate:\n" +
			"   a. *Confirm* that all changes are committed and the code builds clean.\n" +
			"   b. *Run* 'pull' to merge the latest known-good code into your local copy.\n" +
			"   c. *Build* the code and ensure it passes.\n" +
			"      (If it doesn't, fix the problem and start over.)\n" +
			"   d. *Confirm* that the integration machine is available and no one has\n" +
			"      integrated since you pulled. (If they have, start over when they're done.)\n" +
			"   e. *Run* 'push' to copy your code to the integration machine.\n" +
			"   f. *Run* 'promote' on the integration machine to build the code and merge it\n" +
			"      into the integration branch. (If the integration machine build fails,\n" +
			"      fix the problem on your machine and start over.)\n"
		);
	});

	desc("Reset repository to last known-good integration. DESTRUCTIVE.");
	task("reset", function(confirm) {
		if (confirm !== "y") {
			console.log("This command will erase all your un-integrated work.");
			console.log("To confirm, run using 'reset[y]'");
			process.exit();
		}

		sh([
			"git pull",
			"git reset --hard origin/integration",
			"git clean -fd"
		], complete);
	}, {async: true});

	desc("Get latest known-good code and merge it into current branch.");
	task("pull", function() {
		sh([
			"git pull origin integration"
		], complete);
	}, {async: true});

	desc("Push commits to integration machine for validation.");
	task("push", function() {
		sh([
			"git push"
		], complete);
	}, {async: true});

	desc("Merge code into integration branch. INTEGRATION BOX ONLY.");
	task("promote", function(branch) {
		if (!branch) {
			console.log(
				"This command will build your code and merge it into the integration\n" +
				"branch. Pass your branch name as a parameter (e.g., 'promote[myBranch]').\n" +
				"This command must be run on the master integration machine."
			);
			process.exit();
		}

		function checkoutAndBuild(successCallback, failureCallback) {
			sh([
				"git checkout " + branch
			], function() {
				shWithErrorHandler(BUILD_COMMAND, successCallback, failureCallback);
			});
		}
		function afterSuccessfulBuild(callback) {
			sh([
				"git checkout integration",
				"git merge " + branch + " --no-ff --log"
			], callback);
		}
		function afterFailedBuild(callback) {
			sh([
				"git checkout integration"
			], function() {
				fail("Build failed. Integration machine has been reset to known-good state.");
				callback();
			});
		}

		checkoutAndBuild(afterSuccessfulBuild, afterFailedBuild);
	});

	function sh(commands, callback) {
		function serializedExec(command) {
			if (command) {
				shWithErrorHandler(command, function() {
					serializedExec(commands.shift());
				}, function() {
					fail("shell command exited with error code");
				});
			}
			else {
				callback();
			}
		}
		serializedExec(commands.shift());
	}

	function shWithErrorHandler(oneCommand, successCallback, failureCallback) {
		var process = jake.createExec(oneCommand, {printStdout:true, printStderr:true});
		process.on("cmdEnd", function() {
			successCallback();
		});
		process.on("error", function() {
			failureCallback();
		});

		console.log("> " + oneCommand);
		process.run();
	}
}());