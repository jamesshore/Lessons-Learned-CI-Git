// Copyright (c) 2012 Titanium I.T. LLC. All rights reserved. See LICENSE.txt for details.

var BUILD_COMMAND = "./jake.sh";

/*global desc, task, jake, fail, complete */
(function() {
	"use strict";

	desc("Usage instructions");
	task("default", function() {
		console.log(
			"Usage:\n" +
			"1. For instructions on setting up your repository, run 'init'.\n" +
			"2. When starting fresh, run 'reset' to get back to known-good state.\n" +
			"3. When you're ready to integrate:\n" +
			"   a. *Confirm* that all changes are committed and the code builds clean.\n" +
			"   b. *Run* 'pull' to merge the latest known-good code into your local copy.\n" +
			"   c. *Build* the code and ensure it passes.\n" +
			"      (If it doesn't, fix the problem and start over.)\n" +
			"   d. *Confirm* that the integration machine is available and no one has\n" +
			"      integrated since you pulled. (If they have, start over when they're done.)\n" +
			"   e. *Run* 'push' to copy your code to the integration machine.\n" +
			"   f. *Run* 'promote' on the integration machine to build the code and merge it\n" +
			"      into the integration branch. (If the integration machine build fails,\n" +
			"      fix the problem on your machine and start over.)\n"
		);
	});

	desc("Instructions for setting up repository");
	task("init", function() {
		console.log(
			"To set up your Git repository for continuous integration:\n" +
			"1. Choose an unused development workstation to use as the integration machine.\n" +
			"2. Merge all your unintegrated code into a single repository and get it to\n" +
			"   build clean. This will be your master integration repository.\n" +
			"3. Copy your master integration repository to the integration machine.\n" +
			"4. Make sure the repository HEAD points to your integrated, known-good code.\n" +
			"5. Create an integration branch by running 'git checkout -b integration'.\n" +
			"   (This will also switch you to that branch.)\n" +
			"6. Create a branch for each development workstation by running\n" +
			"   'git branch <workstation_name>' for each one.\n" +
			"7. Clone the integration machine's repository to each development machine by\n" +
			"   running 'git clone <integration_repository_url>' on each dev machine.\n" +
			"8. Switch each development workstation to use its own branch by running\n" +
			"   'git checkout <workstation_name>' on each one.\n" +
			"9. That's it!\n"
		);
	});

	desc("Reset repository to last known-good integration. DESTRUCTIVE.");
	task("reset", function(confirm) {
		if (confirm !== "y") {
			console.log("WARNING: This command will erase all your un-integrated work.");
			console.log("To confirm, run using 'reset[y]'");
			process.exit();
		}

		sh([
			"git clean -fd",                            // Remove extraneous files
			"git reset --hard origin/integration",      // Eliminate conflicts
			"git pull",                                 // Get updates to integration branch location
			"git reset --hard origin/integration"       // Sync with latest integration branch
		], complete);
	}, {async: true});

	desc("Get latest known-good code and merge it into current branch.");
	task("pull", ["status"], function() {
		sh([
			"git pull origin integration"
		], complete);
	}, {async: true});

	desc("Push commits to integration machine for validation.");
	task("push", ["status"], function() {
		sh([
			"git push"
		], complete);
	}, {async: true});

	desc("Merge code into integration branch. INTEGRATION BOX ONLY.");
	task("promote", ["status"], function(branch) {
		if (!branch) {
			console.log(
				"This command will build your code and merge it into the integration\n" +
				"branch. Pass your branch name as a parameter ('promote[workstation_name]').\n" +
				"CAREFUL: This command must only be run on the master integration machine.\n"
			);
			process.exit();
		}

		function checkoutAndBuild(successCallback, failureCallback) {
			sh([
				"git checkout " + branch
			], function() {
				shWithErrorHandler(BUILD_COMMAND, successCallback, failureCallback);
			});
		}
		function afterSuccessfulBuild() {
			sh([
				"git checkout integration",
				"git merge " + branch + " --no-ff --log"
			], complete);
		}
		function afterFailedBuild() {
			sh([
				"git checkout integration"
			], function() {
				fail("Build failed. Integration machine has been reset to known-good state.");
				complete();
			});
		}

		checkoutAndBuild(afterSuccessfulBuild, afterFailedBuild);
	}, {async:true});

	// Ensure there aren't any files that need to be checked in or ignored
	task("status", function() {
		sh(["git status --porcelain"], function(stdout) {
			if (stdout[0]) fail("Working directory contains files to commit or ignore.");
			complete();
		});
	}, {async:true});

	function sh(commands, callback) {
		var stdout = [];
		function serializedExec(command) {
			if (command) {
				shWithErrorHandler(command, function(oneStdout) {
					stdout.push(oneStdout)
					serializedExec(commands.shift());
				}, function() {
					fail("shell command exited with error code");
				});
			}
			else {
				callback(stdout);
			}
		}
		serializedExec(commands.shift());
	}

	function shWithErrorHandler(oneCommand, successCallback, failureCallback) {
		var stdout = "";
		var process = jake.createExec(oneCommand, {printStdout:true, printStderr:true});
		process.on("stdout", function(data) {
			stdout += data;
		});
		process.on("cmdEnd", function() {
			successCallback(stdout);
		});
		process.on("error", function() {
			failureCallback(stdout);
		});

		console.log("> " + oneCommand);
		process.run();
	}
}());